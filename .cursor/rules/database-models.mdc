---
description:
globs:
alwaysApply: false
---
# Database Models and Structure

## Directory Structure

```
src/presales/db/
├── __init__.py
├── base.py          # Base model and DB connection
├── models/          # Database models
│   ├── __init__.py
│   ├── client.py    # Client model
│   ├── subscription.py # Subscription model
│   ├── ticket.py    # Ticket model
│   └── user.py      # User model
├── migrations/      # Database migrations
│   ├── __init__.py
│   ├── env.py
│   └── versions/    # Migration versions
├── repositories/    # Repository pattern implementations
│   ├── __init__.py
│   ├── base.py      # Base repository
│   ├── client_repository.py  # Client repository
│   ├── subscription_repository.py # Subscription repository
│   ├── ticket_repository.py  # Ticket repository
│   └── user_repository.py    # User repository
└── session.py       # Session and connection management
```

## Database ORM Selection

For this application, we'll use SQLAlchemy with PostgreSQL:

1. **Benefits**:
   - Full ORM capabilities with relationship mapping
   - Support for migrations with Alembic
   - Compatibility with FastAPI's async features
   - Strong type support with Python typing

2. **Alternatives**:
   - For simpler applications: SQLite
   - For document-based data: MongoDB with Motor
   - For high-performance needs: direct PostgreSQL with asyncpg

## Base Model Pattern

```python
# In db/base.py
from datetime import datetime
from typing import Any, Dict, List, Optional, Type, TypeVar
from uuid import UUID, uuid4

from sqlalchemy import Column, DateTime, String, func
from sqlalchemy.dialects.postgresql import UUID as SA_UUID
from sqlalchemy.ext.declarative import declarative_base, declared_attr

class CustomBase:
    """Base class for all models."""
    
    @declared_attr
    def __tablename__(cls) -> str:
        """Generate table name automatically based on class name."""
        return cls.__name__.lower()
        
    # Common columns for all models
    id = Column(SA_UUID, primary_key=True, default=uuid4, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    def dict(self) -> Dict[str, Any]:
        """Convert model instance to dictionary."""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Model":
        """Create model instance from dictionary."""
        return cls(**{
            k: v for k, v in data.items() 
            if k in cls.__table__.columns.keys()
        })

# Create base model
Base = declarative_base(cls=CustomBase)

# Type variable for model classes
Model = TypeVar("Model", bound=Base)
```

## Model Examples

### User Model

```python
# In db/models/user.py
from sqlalchemy import Boolean, Column, String, Text
from sqlalchemy.dialects.postgresql import JSONB

from ..base import Base

class User(Base):
    """User model for authentication."""
    
    email = Column(String(255), unique=True, index=True, nullable=False)
    name = Column(String(255), nullable=False)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    preferences = Column(JSONB, default=dict)
    
    # Relationships defined here
```

### Client Model

```python
# In db/models/client.py
from sqlalchemy import Column, ForeignKey, String, Text, Integer
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from uuid import UUID

from ..base import Base

class Client(Base):
    """Client model for businesses subscribing to services."""
    
    name = Column(String(255), nullable=False)
    description = Column(Text)
    contact_email = Column(String(255), nullable=False)
    contact_phone = Column(String(50))
    address = Column(Text)
    subscription_tier = Column(String(50), default="standard")
    monthly_fee = Column(Integer, default=7500)  # €7,500 default
    metadata = Column(JSONB, default=dict)
    
    # Relationships
    subscriptions = relationship("Subscription", back_populates="client")
    tickets = relationship("Ticket", back_populates="client")
    users = relationship("User", secondary="client_users")
```

### Subscription Model

```python
# In db/models/subscription.py
from sqlalchemy import Column, ForeignKey, String, Text, Integer, Date, Boolean
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from uuid import UUID

from ..base import Base

class Subscription(Base):
    """Subscription model for client service subscriptions."""
    
    client_id = Column(SA_UUID, ForeignKey("client.id"), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date)
    status = Column(String(50), default="active")  # active, paused, cancelled, expired
    tier = Column(String(50), default="standard")
    monthly_fee = Column(Integer, default=7500)  # €7,500 default
    is_auto_renew = Column(Boolean, default=True)
    payment_status = Column(String(50), default="pending")  # pending, paid, overdue
    settings = Column(JSONB, default=dict)
    
    # Relationships
    client = relationship("Client", back_populates="subscriptions")
```

### Ticket Model

```python
# In db/models/ticket.py
from sqlalchemy import Column, ForeignKey, String, Text, Integer, Boolean, DateTime
from sqlalchemy.dialects.postgresql import JSONB, ARRAY
from sqlalchemy.orm import relationship
from uuid import UUID
from datetime import datetime

from ..base import Base

class Ticket(Base):
    """Ticket model for client requests."""
    
    client_id = Column(SA_UUID, ForeignKey("client.id"), nullable=False)
    created_by_id = Column(SA_UUID, ForeignKey("user.id"), nullable=False)
    assigned_to_id = Column(SA_UUID, ForeignKey("user.id"))
    
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=False)
    status = Column(String(50), default="pending")  # pending, in_progress, completed, blocked
    priority = Column(String(50), default="medium")  # low, medium, high, critical
    
    # Assessment fields
    complexity = Column(String(50))  # S, M, L, XL, XXL
    estimated_hours = Column(Integer)
    projected_value = Column(String(255))
    eta_date = Column(DateTime(timezone=True))
    
    # Additional fields
    tags = Column(ARRAY(String(50)), default=list)
    metadata = Column(JSONB, default=dict)
    is_archived = Column(Boolean, default=False)
    
    # Automated assessment
    ai_assessment = Column(JSONB, default=dict)
    assessment_date = Column(DateTime(timezone=True))
    
    # Relationships
    client = relationship("Client", back_populates="tickets")
    created_by = relationship("User", foreign_keys=[created_by_id])
    assigned_to = relationship("User", foreign_keys=[assigned_to_id])
    updates = relationship("TicketUpdate", back_populates="ticket")
```

### TicketUpdate Model

```python
# In db/models/ticket.py (continued)
class TicketUpdate(Base):
    """Updates and notes on tickets."""
    
    ticket_id = Column(SA_UUID, ForeignKey("ticket.id"), nullable=False)
    user_id = Column(SA_UUID, ForeignKey("user.id"), nullable=False)
    
    content = Column(Text, nullable=False)
    update_type = Column(String(50), default="note")  # note, status_change, assignment
    previous_status = Column(String(50))
    new_status = Column(String(50))
    metadata = Column(JSONB, default=dict)
    
    # Relationships
    ticket = relationship("Ticket", back_populates="updates")
    user = relationship("User")
```

## Repository Pattern

### Base Repository

```python
# In db/repositories/base.py
from typing import Generic, List, Optional, Type, TypeVar, Any, Dict, Union
from uuid import UUID

from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession

from ..base import Base, Model

T = TypeVar("T", bound=Base)

class BaseRepository(Generic[T]):
    """Base repository for CRUD operations."""
    
    def __init__(self, session: AsyncSession, model: Type[T]):
        """Initialize repository with session and model."""
        self.session = session
        self.model = model
    
    async def create(self, obj_in: Union[Dict[str, Any], T]) -> T:
        """Create a new object."""
        if isinstance(obj_in, dict):
            obj = self.model(**obj_in)
        else:
            obj = obj_in
            
        self.session.add(obj)
        await self.session.commit()
        await self.session.refresh(obj)
        return obj
        
    async def get(self, id: UUID) -> Optional[T]:
        """Get object by ID."""
        result = await self.session.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalars().first()
        
    async def get_multi(
        self, *, skip: int = 0, limit: int = 100
    ) -> List[T]:
        """Get multiple objects with pagination."""
        result = await self.session.execute(
            select(self.model).offset(skip).limit(limit)
        )
        return list(result.scalars().all())
        
    async def update(
        self, *, id: UUID, obj_in: Union[Dict[str, Any], T]
    ) -> Optional[T]:
        """Update an object."""
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.dict(exclude={"id", "created_at"})
            
        await self.session.execute(
            update(self.model)
            .where(self.model.id == id)
            .values(**update_data)
        )
        await self.session.commit()
        return await self.get(id)
        
    async def delete(self, *, id: UUID) -> None:
        """Delete an object."""
        await self.session.execute(
            delete(self.model).where(self.model.id == id)
        )
        await self.session.commit()
```

### Specific Repository Example

```python
# In db/repositories/ticket_repository.py
from typing import List, Optional
from uuid import UUID

from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from ..models.ticket import Ticket
from .base import BaseRepository

class TicketRepository(BaseRepository[Ticket]):
    """Repository for ticket operations."""
    
    def __init__(self, session: AsyncSession):
        """Initialize repository."""
        super().__init__(session, Ticket)
    
    async def get_by_client(
        self, client_id: UUID, skip: int = 0, limit: int = 100
    ) -> List[Ticket]:
        """Get tickets for a client."""
        result = await self.session.execute(
            select(Ticket)
            .where(Ticket.client_id == client_id)
            .offset(skip)
            .limit(limit)
        )
        return list(result.scalars().all())
        
    async def get_by_status(
        self, status: str, skip: int = 0, limit: int = 100
    ) -> List[Ticket]:
        """Get tickets by status."""
        result = await self.session.execute(
            select(Ticket)
            .where(Ticket.status == status)
            .offset(skip)
            .limit(limit)
        )
        return list(result.scalars().all())
        
    async def count_by_status(self) -> dict:
        """Count tickets by status."""
        result = await self.session.execute(
            select(Ticket.status, func.count(Ticket.id))
            .group_by(Ticket.status)
        )
        return {status: count for status, count in result.all()}
        
    async def search(
        self, query: str, skip: int = 0, limit: int = 100
    ) -> List[Ticket]:
        """Search tickets by title or description."""
        search_term = f"%{query}%"
        result = await self.session.execute(
            select(Ticket)
            .where(
                (Ticket.title.like(search_term)) | 
                (Ticket.description.like(search_term))
            )
            .offset(skip)
            .limit(limit)
        )
        return list(result.scalars().all())
```

## Database Connection Management

```python
# In db/session.py
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from presales.config import settings

# Create engine
engine = create_async_engine(
    settings.DATABASE_URI, 
    echo=settings.DB_ECHO_LOG,
    future=True
)

# Create session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False,
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Get database session."""
    session = AsyncSessionLocal()
    try:
        yield session
    finally:
        await session.close()
```

## Best Practices

### Database Operations

1. **Use Transactions**:
   ```python
   async def complex_operation(session: AsyncSession):
       """Perform a complex database operation in a transaction."""
       async with session.begin():
           # All operations here are in a transaction
           await session.execute(...)
           await session.execute(...)
   ```

2. **Bulk Operations**:
   ```python
   async def bulk_insert(session: AsyncSession, objects: List[T]):
       """Insert multiple objects at once."""
       session.add_all(objects)
       await session.commit()
   ```

3. **Custom Queries**:
   ```python
   async def get_active_tickets_count(session: AsyncSession):
       """Get count of active tickets."""
       result = await session.execute(
           select(func.count())
           .select_from(Ticket)
           .where(Ticket.status != "completed")
       )
       return result.scalar_one()
   ```

### Relationships

1. **Many-to-One Relationship**:
   ```python
   # Ticket belongs to a Client
   client_id = Column(SA_UUID, ForeignKey("client.id"))
   client = relationship("Client", back_populates="tickets")
   ```

2. **One-to-Many Relationship**:
   ```python
   # Client has many Tickets
   tickets = relationship("Ticket", back_populates="client")
   ```

3. **Many-to-Many Relationship**:
   ```python
   # Association table
   user_roles = Table(
       "user_roles",
       Base.metadata,
       Column("user_id", SA_UUID, ForeignKey("user.id"), primary_key=True),
       Column("role_id", SA_UUID, ForeignKey("role.id"), primary_key=True),
   )
   
   # In User model
   roles = relationship("Role", secondary="user_roles", back_populates="users")
   
   # In Role model
   users = relationship("User", secondary="user_roles", back_populates="roles")
   ```

### Indexes and Constraints

1. **Define Indexes for Performance**:
   ```python
   __table_args__ = (
       Index("ix_ticket_client_status", "client_id", "status"),
   )
   ```

2. **Add Constraints**:
   ```python
   __table_args__ = (
       UniqueConstraint("email", name="uq_user_email"),
       CheckConstraint("length(password_hash) > 8", name="ck_password_length"),
   )
   ```

### Migrations

1. **Initialize Migrations**:
   ```bash
   alembic init migrations
   ```

2. **Generate Migration**:
   ```bash
   alembic revision --autogenerate -m "Initial migration"
   ```

3. **Apply Migration**:
   ```bash
   alembic upgrade head
   ```

4. **Rollback Migration**:
   ```bash
   alembic downgrade -1
   ```

### Testing

1. **Use Test Database**:
   ```python
   @pytest.fixture
   async def test_db():
       """Create test database."""
       # Create test engine
       test_engine = create_async_engine(
           "postgresql+asyncpg://user:pass@localhost/test_db"
       )
       
       # Create tables
       async with test_engine.begin() as conn:
           await conn.run_sync(Base.metadata.drop_all)
           await conn.run_sync(Base.metadata.create_all)
       
       # Create session
       test_session_factory = sessionmaker(
           test_engine,
           class_=AsyncSession,
           expire_on_commit=False,
       )
       
       async with test_session_factory() as session:
           yield session
           
       # Close engine
       await test_engine.dispose()
   ```

2. **Repository Testing**:
   ```python
   async def test_create_ticket(test_db):
       """Test creating a ticket."""
       repo = TicketRepository(test_db)
       ticket_data = {
           "title": "Test Ticket",
           "description": "Test Description",
           "client_id": client_id,
           "created_by_id": user_id,
           "priority": "medium",
       }
       ticket = await repo.create(ticket_data)
       assert ticket.id is not None
       assert ticket.title == "Test Ticket"
   ```

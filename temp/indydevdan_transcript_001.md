welcome back engineers indie Devdan here i'm going to spoil this one and just tell you this video is an absolute banger thanks to Enthropic we have the brand new Clawude 4 model series we have a new Sonnet and a new Opus model and very importantly a lot of engineers are going to miss this but we have Claw Code now generally available this means we can bet big on the best agentic coding tool with now the new state-of-the-art models for effective agentic engineering at scale we have the Opus 4 and the Sonnet 4 models beating out every model for real engineering work this is big today I want to share a dirty dirty parallel AI coding trick you can use to put multiple agentic coding agents to work for you to generate multiple versions of the future of your codebase i have to warn you this is advanced agentic coding and it's not cheap we're going to put together a plan then we're going to deploy that plan against multiple agents working on their own versions of your codebase then we're going to take the best version and merge it back into the main timeline the main branch thanks to the Clawed 4 series this technique has never been more important and it's never been more possible let me show you exactly what I mean let's parallelize our agent coding with the new Claude 4 series so we've gone from iteratively planning to writing larger prompts to writing plans and now we're going to take it a step further we're going to put multiple agents to work for us at the same time in parallel this advanced agent coding technique has massive benefits let's understand what we're working on we're going to operate on a simple codebase called Beni this is the thoughtbench application this is a simple frontend plus backend application that lets us talk to multiple models at the same time you can see we have the brand new Claude and Opus 4 models running so it's really important to showcase multi- aent agent coding against a UI application so we're going to improve this UI update the styling here a little bit but we're going to run multiple versions of cloud code to accomplish this task for us let's set that up cloud code is updated it's generally available this is big news that means we can bet big on clawed code we can type /model we can select our model i'm going to go ahead and use the brand new topofthe-line Opus 4 model here in order for us to get this work done we create plans adobe AI coding is the 2024 way of doing things if you want to ship a ton of value you want to sit down plan out your work and then fire it off to a powerful agent coding tool so we have this UI revamp prompt inside of the codebase basically it's detailing all the work we want done the top line here is that we want to transform ThoughtBench into a high density information dashboard while maintaining a great user experience so this is the prompt we want to run normally I would copy the reference to this with command shift R that's my hotkey for this and then I'd say implement this and then cloud code would run this execute it you know update our current branch but we can do a lot better by running multiple agents in their own environments so what does that look like if we open up.claude.coms inside of the beni codebase you'll see this simple init parallel prompt what is this prompt doing this prompt is going to set up our new git work trees as you saw here in this diagram we can use this git command get work tree add to specify a location right so you can see in our trees directory here we're going to create a UI revamp one directory and it's going to basically duplicate our entire Beni codebase we can of course scale this up right we want multiple agents building out the exact same feature lms are non-deterministic by nature so by parallelizing them we can get different versions of the future of our codebase and then we can select the best one so let's kick this off and then we'll break down the prompt as it's executing so we're going to type slash simple and it parallel you can see here inside of the prompt we're setting up a variable this is a technique I like to use to reference variables throughout the prompt cloud code / commands lets us set up and pass in variables so I'm going to name this feature we're going to call it UI rewrite and that's it so we're passing in one parameter this is going to replace this here and let's kick this prompt off so claude code running on claude 4 opus is going to create our trees directory you can see that command right there and then it's going to execute these steps in parallel it's going to create a new git work tree it's going to copy the end environment variable into the write folder and it's going to CDN to the server install dependencies do the same thing on the front end using bun update our vite config to run on a different port remember we want to run these in parallel we want to compare all the results and you can see here our agenda workflow is running in parallel it's kicking off all these tasks in their own dedicated environments if we open up UI rewrite one you can see here we have a direct clone of the entire codebase there's cloud there's the client there's the server right so it's the exact same thing as the root of the application we've quite literally thanks to git work trees cloned our entire codebase into three separate versions i hope you can see where this is going right there we go we have our Vite config update let's go ahead and turn on autoedit mode and now we're going to get parallel writes and as Opus runs into errors right it's just going to work through them it's going to fix them it's updating every version of our application we have entire environment set up there's the get work tree list we now have three brand new work trees and Cloud 4 Opus has completed this agentic workflow and to be completely clear you know that's what this is all right this is not a prompt right we're not running traditional prompts anymore we're running agentic workflows principal AI coding members know these as ADW's AI developer workflows ai coding is not enough we need more than just generating code we need engineering workflows we're interacting with Git we're interacting with the file system we're writing code we're updating files right there's a lot more going on in day-to-day engineering tasks we've created three new work trees and they're all operating on their own branch so this is the setup process all right we already have our plan and now we're setting up our code bases so we're not quite building yet but we do have our branches and our trees set up for our agents to operate in so this is a powerful parallel agentic coding workflow you can use to scale your impact i'm going to show you in just a second how powerful this can be all right because we're going to get multiple versions is we're going to get multiple future realities of this codebase that we can pick the best pieces from and you can choose exactly what you want to go back into the main timeline aka your main branch all right so right now we're about right here let's go ahead and continue our journey we have all of our code bases set up let's go ahead and give our agents access to what they need to ship this feature let's go ahead and open up.claude back into the commands directory this is one of three essential directories for agent coding but let's open up the exe.p parallel so this is where we're actually going to fire off every one of our agents you can see here we have that same workflow right we have variables at the top our variables here are the plan that we want to execute and the number of parallel work trees so the number of agents that we want to fire off you can see the rest of this prompt is pretty straightforward we're basically saying give every agent their own dedicated codebase and pass off this plan to them okay so let's just kick this off right i'm going to run /exe parallel um the plan we want to execute is let's go ahead and pass in our UI revamp okay so we're going to update the thoughtbench application all right copy the reference to this and I'm going to pass this in here as the first argument when you're working with cloud code/comands it's based on the index so the first argument here is going to be you know our first parameter and then the second one is going to be whatever we pass in next for the number of parallel work trees and our simple init parallel we set up three so I'm just going to pass in the number three there this is going to be really powerful claude 4 Opus is now going to spin up three instances right it's going to set up three subtasks three parallel subtasks and it's going to start building out this feature that we've you know fully planned here uh you know viewers of the channel and principal AI coding members you know that great planning is great prompting um I'm going to repeat this over and over and over because it becomes more and more relevant as you get access to more compute the best way to communicate is to write clearly is to think clearly it's to plan and then we hand off these great packages to our AI coding tool this is what we're going to do now but instead of doing it with just an AI coding tool or even an agent coding tool we're passing it off to the state-of-the-art cloud for Opus in multiple instances okay this is this is big okay we talk about scaling we talk about longunning agentic workflows and longunning agentic coding jobs this is how we scale even further beyond let's kick this off without further ado bam this is going to get to work for us in the background okay so you know we had a couple of commands to run i wanted to understand the codebase well first I wanted to go back to the root i then wanted to understand the highle structure of the codebase by looking at the server and client directory it's going to run tree to understand you know a deeper look at the codebase and then it's going to read the plan we passed in right so UI revamp so there we So now it's going to read the UI revamp plan fantastic so this is where you know a lot of your engineering work is going to happen now moving forward is in the planning it's in the thinking it's in the engineering of the work you want done and then we're going to create three parallel agents to implement the spec in their own respective code bases okay so this is going to be really important you're going to see three tasks kick off here and uh I'm really excited for this um this feature is absolutely insane so there's we got some tokens leaking in here um some Opus tokens right so this is this is very expensive you know by the way you know kicking off this many agents doing this much work is expensive this is advanced agent decoding so there it is these are all running in parallel okay it looks like this top one is the only one running these are actually all running at the same time we're going to let this run this is actually going to take quite a bit of time this is a non-trivial set of work so we're going to let our agents run here we have auto accept on uh inside of our settings we have enabled several um let's go ahead I can show that to you know inside of our settings we have several commands just default on enabled to let cloud code cook so that's that um while this is running let's talk about why you would want to do this okay why do you want parallel workflows what are the concrete advantages of this right what what what's the true edge that we're getting right every week every Monday I try to come to the table quite literally to the table here and I I want to give you valuable engineering insights you can use right handson in your engineering work okay so how is this useful for you handson let's talk about it um you know you can see we're still working there uh let's go ahead and open up the readme and let's break down a couple of key ideas here okay so why run in parallel llms are nondeterministic probabilistic machines okay that means that every time you run you're going to get a different result right the same prompt will give you different results especially when we're talking about the scale that we're trying to operate at okay i don't care about one-off uh quick changes i don't care about green field applications i don't care about small tweaks here and there i'm talking big longunning jobs running tons of engineering work that's where we're aiming on the channel we want a ton of work done by Aentric Coding tools and beyond with those longunning jobs we can be guaranteed that if we run it twice we're going to get different results okay now you might think that's a bug it's not this is a feature right just like you and I we are nondeterministic token generating machines okay that the thing I'm going to say next duck banana infinity stones right you won't always know what I'm going to say next okay you can guess right you can have high probability right especially if you're operating in the domain space that I am and that we are but you cannot know for sure the next token I'm going to generate here right that's part of why you show up every single week okay it's because the tokens I'm generating right they're differentiated tokens right in this video it's it's another example of that make sure you're subscribed blah blah blah okay so so this is a feature okay not a bug that's my point here we can leverage this to see multiple versions of the future okay uh we now have the capabilities to build out multiple futures of our codebase and then you can choose the best outcome this is why this is so powerful okay by running multiple agents in parallel we can do this we can hedge against model failures on complex tasks it's very possible one of these tasks is just going to fail all right it's it's not going to update the UI it's going to run to some bug you can see 17 tool calls there it's just going to fail okay so that's very possible and and the advantage here with multiple agentic workflows running right we have multiple agents working for us the advantage here is that you know two of these might work or one of these might work right and you can spin up way more than just three agents here okay i'm just showing this off this is a simple minimalistic example that I want to share with you here so so this is one reason to run multiple agents in parallel right this already beats out you doing this by yourself running a single instance okay let's look at number two we can get different perspectives on the same problem and then you know once again we can choose the best so why is this important so for something like user interfaces which is a great example of this we might have a general direction of what we want but we might not know the exact version we want right in our case we are revamping the UI there are many acceptable versions of this right and as you'll see in this video there are multiple end states here that we're going to end up looking at all right so third we can isolate and delegate our engineering work to you know two to n agents there really is no limit on this okay i just chose three it's a great number it's a great place to start you want three different versions and um you know this is going to give you a great starting set of futures of your codebase to choose from right we're going to be able to merge the best of three right so we're getting you know again 3x chances because we're using directx compute to improve the final result that we have so this is why we run in parallel so let's go ahead and take a look at our code here it looks like agent 2 check this out agent 2 is complete used only 10 tools very interesting uh let's go ahead and uh it looks like it wants to tail it looks like it's fixing something let's go ahead and just accept so you can see very cool right so uh Opus ran 10 tools 67,000 tokens ran for 5 minutes inside of task 2 okay so task 3 and task one are still running you can see here we have a ton of tool uses in codebase 1 we're definitely going to get some very different results right we can already see that just based off the number of tool calls okay so this is going to need some more time to run you can see uh task one still stacking up there the tool calls you can see we just got our results.m MD right um and that's that should be the end of the parallel tool if we search for results.mmd you can see there that was one of the last commands there all right so you can see here we got task one also completed now so task one took 9 minutes okay basically 10 minutes all right so look at these long running agentic workflows right 80k of Opus tokens there's going to be a lot of value in there and our third agent is still running so it's got 24 tools in use so this is going to be a pretty great result let's go ahead and let it finish up and let's just briefly talk about when to use this powerful technique because you don't always want to whip this out right again as you can see it's going to take some time but the nice part is we're building out multiple of these in parallel so it's almost like it'll always just take the duration of your longest agent there's definitely an argument for just constantly using multi- aent get work trees but let's go ahead and just take a look at this okay so you know when to use the technique it's fairly simple okay it's perfect for you know instate ambiguous tasks when you have UI work where many versions can be acceptable okay when you think one of your hits one of your agents might fail when you think you're working on a hard task fire off three fire off five agents and then see which one you know maybe pulled it off and then of course this is probably the most important one i probably should have put this one first you need to have a clear plan okay okay and you need to have enough work worth putting in its own branch okay there is a huge argument for always using plans right pretty much all my work comes out of a spec now I'm thinking I'm writing I'm planning I'm AI drafting with my agent coding tools they're helping me plan now if you can't write a plan right if you need to iteratively prompt you probably shouldn't use uh parallel workspaces right it just isn't going to make sense you probably should just iterate on your own codebase if you have any one of these and specifically if you have three right if you can plan your work if you can see ahead if you do know what you're looking for uh parallelism is going to be really really powerful so here we are agent 3 we're up to 33 tool uses so while this is working we're going to need a front-end script to boot up all of our front-end servers so inside of the initialization uh parallel script here I only updated the client port this is because we're only making a front-end change so we can actually run the main server here which so we should be able to just use our existing code bases okay check this out this is awesome we have all three agents finished so let's go ahead and look at that total runtime okay so check this out right we have three agents that ran 9 minutes 5 minutes 14 minutes there is our summary so we got our results summary in order to spin these up I would love to just look at these side by side create start treeclients.sh sh say for each work tree start the client and let's go ahead and kick that off okay there we go let's go ahead and check this out start clients we can go ahead and just look at this yep this is perfect ui rewrite and then you can see we're running it's got some nice logging here for us and then we're going to wait for all the processes looks great let's go ahead and kick that off okay there we go it's giving us the permission to unlock that file great so let's go ahead and kick off this file and you know to note if we type gs here get status uh we only have this one change in our primary branch right all the other changes have been isolated into our trees but okay without further ado let's go ahead and yeah copy this sh kick that off we're going to start all of our clients at the same time so let's go ahead and boot these up client one client two client three these are all connected to the main server so let's go ahead and kick these off you can see a little bit of difference already let's go into the thought bench application because that's where change was focused so there's one there's two there's three and check this out guys so here's the original right so we can type hi here there's the prompt right it's going to kick off blah blah blah all looks good and then here are our other versions okay so here's the uh version one you can see we have a terminalike style here's version two look at this really like this one really clean right kind of modern i love this like highlighting blue modern style here and yeah we can kick off a prompt here let's see this work yeah nice look at that so interesting kind of an overlay setup right very kind of futuristic look um a little bit harder to read here and obviously you know there's some styling problems here but you know that's not the focus obviously we can come in with follow-up prompts clean things up i really want you to focus here on the fact that we have multiple working versions of the application that we can play with here's version three very interesting right so we can say "How are you?" Just some whatever filler prompt and check this out right so I like this version too it's a bit more just straightforward let's go ahead and reset here and type hello this version is like really compressing the overlays to save space you can see all the font is a lot smaller this is really cool right we have multiple working versions of this new application okay um I got to say I like the second version the best right thought bench it it kind of fits our our previous kind of you know theme it just kind of takes it to the next level obviously we have some styling fixes here to improve but I love the buttons i love the styling i love the feel of this and we do save a little bit more space here by having them a little bit more compressed right we can go ahead and reset type high and yeah I like the way that these these loaders are set up as well anyway this is awesome right we have multiple versions of our workspace right we created three versions of our application we updated the client in every version with cloud code running cloud for opus we wrote a plan this is really important right we have to know where our role is okay so we wrote a plan we parallelized our agents to run in their own isolated environments executing against the exact same plan and then here we are let's go ahead and merge the best take so I like right this second version just as if I was an engineer operating in this codebase i'm going to open up cursor and I'm going to go into trees this is UI rewrite i think this is two all right so you know we are now inside of a version of the application and um let's see how can I identify this we should be able to search this port let's go ahead and search this port perfect right so we can see that that port is right here so this is indeed the second version okay we can run get status here to see all of our changes and then we can run you can see we're on that second right second branch here's the results file this is a great pattern for having your independent agents summarize all their work everything's working as intended and now we can uh also just check uh get diff so we can see uh I think we need stat head is that right yeah there we go so you know compared to the main branch you know we had uh 630 lines changed here agentically we didn't touch anything we didn't do anything all we did was plan right once again great planning is great prompting every principal a coding member knows that i highly recommend if you're not planning your work i think you're probably starting to fall behind the next wave of what can be done with with agent coding tools like this okay so let me go ahead and what I'm going to do here is I'm going to fully commit so I'm going to say GCM i'll say UI rewrite um agent 2 and I'm just making some crap up here just as if I was an engineer operating on this branch i'm just going to get push this okay okay so we have rewrite two pushed now I'm going to come back to the main branch okay you can see there's the work trees if we run git branch here this is you know git branch i have short codes for all this to move faster you can see all the primary branches there now we're going to merge in uh branch two right so we can see we have our start client we can go ahead and commit that and let's go ahead and merge that branch in so I'm going to copy this and just as as you would with another engineer we run git merge this branch bam there are all those changes now we should be able to see our original branch right here's the original version if we refresh oops if we open up that vite file we can see we did get that merging so I'm going to reset this back to the original port i'm going to kick off our script here open this up and if we go into thoughtbench now we of course have that new updated version okay so like I mentioned you know there's still some fixes here right we need to make sure that make sure that this text is readable um we can now back in our main branch if we wanted to you know deploy a quick change to make sure that that text is is readable you know we can always just open up clawed instances and fix these changes i'm not going to focus on that right now i just wanted to highlight this interesting idea of having multiple agents working for you in parallel in the background now we have multiple versions of this application that we can pick and choose from and the sky is really the limit here you can set up as many agents as you want to if you check out the Beni codebase link in the description I have a nit parallel as well which takes a more dynamic approach where we can create however many parallel work trees we want in a single shot all right and this enables you know once again instead of just running three agents we can run you know three to n agents and the whole purpose here is that we have multiple shots at the future that we're looking for right we have multiple perspectives we have multiple versions some successful and we get to pick right we get to merge the best this is git work trees parallel agentic coding plan your work run multiple agents in parallel with git work trees pick the best merge the best and then keep shipping this enables you to pick multiple best versions you're not just writing fast you're not just you know generating a lot of value for your company for your work you're generating the best of end possibilities for your work for your company for your engineering okay merge the best this is just one of many ways is we're exploring how to maximize our engineering impact with compute make sure you're subscribed and if you haven't already make sure you check out principled AI coding this is a foundational course I built to help you excel with the AI coding tools of today and tomorrow in this course we use the old school AI coding tool Ader in the next course that I'm working on as we speak week after week we're going to be talking a lot more about agentic coding but it's really important for you to set up your foundations okay in this course we set up the foundations the principles of AI coding and this is the only way I'm able to literally 6 months after this course has been released I'm able to still reference this course and the ideas in it okay context model prompt go from beginner to intermediate to advanced it's all there make sure you get the value embedded inside this course close the loop let the code write itself adws as you saw here AI developer workflows also known as agentic workflows this is a reality this is no longer something that's hard to do this is something that you can do right now if you want that extra ump if you want to prepare for what's next check out principal AI coding like I mentioned I am actively working on part two phase two of this course where we're going to push everything we've done in principal ed coding into the next level with agentic coding cloud 4 is here cloud code is out of research preview this is all big news cloud 4 Opus is insane cloud 4 sonnet is a great workhorse we have more tools to leverage compute take these ideas write with multiple agents at the same time get more work done choose the best of N you have more compute than ever available to you i highly highly recommend you invest in this tooling there's a reason I've talked about cloud code literally month after month now you know literally like eight videos in a row it's because I can sense the signal and as we've seen here with the code with claude you know announcement and everything that was released here I hope you can start to see the signal too cloud code is a differentiated agentic coding tool check out previous videos to understand more there's lots more to discuss here there's lots more edge I have to give you so make sure you don't miss it we're pushing into the agent coding future we're now running multiple agents in parallel to scale our compute to scale our success you know where to find me every single Monday stay focused and keep building

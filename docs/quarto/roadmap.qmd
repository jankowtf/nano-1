---
title: "Nanobricks Roadmap"
subtitle: "From v0.1.0 to Production-Ready Framework"
format: 
  html:
    toc: true
    toc-depth: 3
---

## Introduction

This roadmap synthesizes feedback from real-world usage of nanobricks (particularly from the nano-scorm project) and outlines our path forward. The framework's core abstractions have proven solid, but we need to reduce friction and provide clearer guidance for common patterns.

## Current State: v0.1.0

### What's Working Well

- **Core Protocol**: The `Nanobrick[Input, Output]` abstraction is intuitive and powerful
- **Skills System**: The `@skill` decorator pattern for cross-cutting concerns is a major hit
- **Type Safety**: Generic typing provides excellent IDE support and catch errors early
- **Async-First**: Modern design that works well with contemporary Python patterns

### Key Achievements

- Successfully used to build production-grade applications (nano-scorm)
- ~55% code reduction compared to manual implementation
- 70% reduction in API boilerplate through skills system
- Proven composition patterns for complex workflows

## Immediate Priorities

Based on real-world feedback, we're taking a pragmatic approach with patch releases for backwards-compatible improvements before major feature additions.

## Version 0.1.1: Documentation & Examples

**Theme**: Zero code changes, maximum clarity

### Priority Documentation
- **Cookbook Examples**: Step-by-step guides for common patterns
- **Dependency Injection Guide**: Clear documentation on using the `deps` parameter
- **Error Handling Patterns**: Best practices for exceptions vs Result types
- **Testing Patterns**: How to test individual bricks and pipelines
- **Architecture Decision Guide**: When to use composition vs inheritance

## Version 0.1.2: Type Improvements

**Theme**: Backwards-compatible enhancements to reduce friction

### Type System Enhancements
- **Type Adapter Utilities**: Helper functions to adapt between mismatched types for pipe operator
- **Generic Result Type**: Optional `Result[T, E]` import for standardized error handling
- **Better Error Messages**: Improved type mismatch errors for pipe operator
- **Type Conversion Helpers**: Common adapters for string↔dict, list↔tuple, etc.

## Version 0.1.3: Core API Refinement

**Theme**: Simplify and clarify the core API based on user feedback

### API Improvements
- **Rename `NanobrickSimple` to `Nanobrick`**: The "Simple" suffix is confusing since there's no complex variant
  - Keep `NanobrickBase` as the abstract base class for advanced use cases
  - `Nanobrick` becomes the primary class for 99% of use cases
  - Backwards compatible: `NanobrickSimple` remains as deprecated alias
- **Enhanced Git Integration**: Smart git tasks with better commit messages
  - `task version:release` for complete release workflow
  - Auto-generated commit messages based on CHANGELOG entries
  - Integrated version bumping, tagging, and pushing
- **Date Handling in Tasks**: Use system date commands for accurate timestamps
  - Remove hardcoded dates from documentation
  - Dynamic date generation in version tasks

### Developer Experience
- **Clearer Class Hierarchy**: 
  - `Nanobrick[T_in, T_out]` - Primary class for stateless bricks (was NanobrickSimple)
  - `NanobrickBase[T_in, T_out, T_deps]` - Abstract base for advanced scenarios
  - `NanobrickProtocol` - Type checking protocol
- **Migration Tool**: Script to automatically update imports from `NanobrickSimple` to `Nanobrick`
- **Updated Examples**: All documentation and examples use the new `Nanobrick` name

## Version 0.2.0: Composition Revolution ✅

**Status**: Released 2025-06-05

**Theme**: Address the #1 pain point - strict pipe operator type alignment

### What Was Delivered

1. **Pipeline Builder API**: Fluent interface for complex compositions
   - `Pipeline()` function with method chaining
   - `.branch()`, `.parallel()`, `.merge_with()` for advanced flows
   - `.catch_errors()` for error boundaries
   - `.adapt()` for type conversions
   - `.visualize()` and `.explain()` for debugging

2. **Pipe Operator Migration**: Changed from `|` to `>>`
   - More intuitive arrow syntax
   - Backwards compatibility during transition
   - Migration script included

3. **Test Suite Alignment**: Focused on simplicity
   - Removed tests for non-existent features
   - All tests now passing
   - Framework aligned with core philosophy

### Piping Strategy: Hybrid Approach with `>>` Operator

After extensive analysis of piping approaches across languages (Elixir's `|>`, R's `%>%`, Rust discussions, Python libraries), we've decided on a hybrid approach that balances simplicity with power, using the `>>` (right shift) operator instead of `|`:

#### 1. **Switch from `|` to `>>` for Simple Linear Pipelines**
- **Breaking Change**: Moving from `|` to `>>` for clearer semantics
- Visual arrow metaphor (`>>`) better represents data flow
- Less conflict with bitwise OR operations
- Used by some functional Python libraries (e.g., fn.py)

```python
# New elegant syntax with >> operator
result = LoadData() >> ValidateSchema() >> TransformFields() >> SaveOutput()
```

**Migration from v0.1.x:**
```python
# Old (v0.1.x)
result = Parser() >> Validator() >> Formatter()

# New (v0.2.0)
result = Parser() >> Validator() >> Formatter()
```

#### 2. **Add Pipeline Builder for Advanced Patterns**
- Fluent interface for complex compositions
- Solves type alignment issues with explicit adapters
- Enables branching, merging, and error handling

```python
# New Pipeline builder for advanced cases
pipeline = (
    Pipeline()
    .start_with(Parser())
    .adapt(string_to_dict)  # Explicit type adapter
    .branch(
        ("email", EmailValidator() >> EmailFormatter()),
        ("phone", PhoneValidator() >> PhoneFormatter()),
        ("default", PassthroughValidator())
    )
    .merge_with(CombineResults())
    .catch_errors(ErrorHandler())
    .build()
)
```

#### 3. **Why `>>` Over `|`?**

**Advantages of `>>`:**
- **Visual Clarity**: Arrow metaphor (`>>`) clearly shows data flow direction
- **Semantic Alignment**: Better represents "pipe forward" concept
- **Less Ambiguity**: `|` often means "OR" in many contexts
- **Precedence Benefits**: Right shift has different precedence than bitwise OR

**Migration Support:**
- Automated migration script to convert existing code
- Deprecation period with warnings for `|` usage
- Clear documentation and examples

#### 4. **Why This Hybrid Approach?**

**Pros:**
- **Clear Semantics**: `>>` operator is more intuitive for piping
- **Progressive Complexity**: Simple cases stay simple with `>>`
- **Type Safety**: Explicit adapters in Pipeline builder
- **IDE Friendly**: Methods are discoverable and documented
- **No Conflicts**: Methods don't clash with operators
- **Familiar Patterns**: Similar to functional programming languages

**Cons Addressed:**
- Breaking change mitigated by migration tools
- Verbosity mitigated by keeping operator syntax for simple cases
- Complexity isolated to advanced use cases only

### Core Enhancements

- **Automatic Type Adapters**: Smart conversion between compatible types
  ```python
  # Automatically insert adapters when possible
  LoadJSON() >> ProcessDict()  # Auto-inserts string_to_dict adapter
  ```

- **Pipeline Debugging**: Visualize and debug compositions
  ```python
  pipeline.visualize()  # Shows flow diagram
  pipeline.explain()    # Details type transformations
  ```

- **Parallel/Branch Support**: Built-in fan-out/fan-in patterns
- **Error Boundaries**: Explicit error handling without breaking the pipeline

## Version 0.2.1: Developer Experience Improvements

**Status**: Released 2025-06-05

**Theme**: Enhanced developer workflow and better Claude Code integration

### What Was Delivered

1. **Task System Namespace Refactoring**
   - Changed from `project:*` to `dev:*` namespace for consistency
   - All project management tasks now under unified `dev:` prefix
   - Improved task discoverability and organization

2. **Improved Symbolic Link Handling**
   - Refactored symlink creation to use absolute paths
   - Better compatibility with Claude Code's file referencing
   - Enhanced logging showing both source and resolved paths
   - Added verification step for symlink creation

3. **Documentation Updates**
   - Updated all task references to use new `dev:` namespace
   - Added README for dependents directory explaining symlink structure
   - Improved clarity in task documentation

### Developer Workflow Enhancements
- **Absolute Path Resolution**: All symlinks now use absolute paths for consistency
- **Better Error Messages**: Clear feedback when symlink operations fail
- **Enhanced Git Integration**: Proper .gitignore entries for dependent projects

## Version 0.3.x: Standard Patterns Library

**Theme**: Common bricks to accelerate development

### Planned Features
- **Common Validators**: Email, URL, phone, regex, range validators
- **Common Transformers**: JSON adapters, type converters, normalizers
- **File Processing Bricks**: CSV, JSON, XML, YAML readers/writers
- **HTTP Client Brick**: Basic requests wrapper with retry logic
- **Data Manipulation**: Filter, map, reduce, aggregate bricks

*Note: This release focuses on providing a comprehensive set of pre-built nanobricks that cover common use cases, reducing the need for developers to build these from scratch.*

## Version 0.4.x: Advanced Developer Experience

**Theme**: Superior tooling and development workflow

### CLI Enhancements

- **Interactive Scaffolding**: `nanobrick new --interactive`
- **Project Templates**: Full application templates (API service, data processor, etc.)
- **Skill Generation**: `nanobrick add-skill logging` to retrofit existing bricks

### Development Tools

- **Pipeline Visualizer**: Generate diagrams from code
- **Performance Profiler**: Identify bottlenecks in pipelines
- **Type Stub Generator**: Better IDE support for dynamic features
- **VS Code Extension**: Snippets, navigation, and debugging support

### Dependency Injection

- **Clear Patterns**: Documentation and examples for the `deps` parameter
- **Service Registry**: Built-in IoC container for shared resources
- **Configuration Injection**: Standardized config management
- **Testing Utilities**: Mock injectors for unit tests

## Version 0.5.x: Comprehensive Standard Library

**Theme**: Batteries-included ecosystem

### Common Bricks Library

- **Data Validation**: Email, phone, URL, schema validators
- **HTTP Operations**: Request/response handling, retries, rate limiting
- **Database Access**: Connection pooling, query builders, ORMs
- **File Processing**: CSV, JSON, XML, Excel readers/writers
- **Message Queues**: Kafka, RabbitMQ, Redis pub/sub
- **Caching**: In-memory, Redis, distributed caches

### Integration Patterns

- **Third-party Libraries**: Adapters for popular packages
- **Framework Bridges**: Integration with FastAPI, Django, Flask
- **Cloud Services**: AWS, GCP, Azure service bricks

## Version 0.6.x: Advanced Features

**Theme**: Production-scale capabilities

### Streaming Support

```python
class StreamProcessor(NanobrickStream[bytes, ProcessedItem]):
    async def invoke_stream(
        self, 
        input_stream: AsyncIterator[bytes]
    ) -> AsyncIterator[ProcessedItem]:
        async for chunk in input_stream:
            yield await self.process_chunk(chunk)
```

### State Management

- **Stateful Bricks**: Clear patterns for maintaining state
- **State Persistence**: Save/restore capabilities
- **Distributed State**: Coordination across instances

### Resource Lifecycle

- **Setup/Teardown Hooks**: Manage expensive resources
- **Connection Pooling**: Built-in resource pools
- **Graceful Shutdown**: Proper cleanup on termination

## Version 1.0: Production Ready

**Theme**: Enterprise-grade stability

*Note: The 1.0 release will mark API stability and production readiness. The exact version progression (0.7.x, 0.8.x, etc.) leading to 1.0 will depend on feature completeness and community feedback.*

### Performance Optimizations

- **Zero-Copy Operations**: Efficient data passing
- **Parallel Execution**: Automatic parallelization where possible
- **Memory Management**: Streaming and chunking for large datasets
- **Profiling Tools**: Built-in performance monitoring

### Observability

- **Distributed Tracing**: Full OpenTelemetry integration
- **Metrics Collection**: Prometheus-compatible metrics
- **Health Checks**: Standardized health/readiness probes
- **Debugging Tools**: Enhanced error messages and stack traces

### Enterprise Features

- **Security**: Sandboxing, permission models, audit trails
- **Compliance**: GDPR, SOC2, HIPAA helpers
- **Multi-tenancy**: Isolation and resource limits
- **High Availability**: Clustering and failover support

## Future Vision (Post-1.0)

*These features represent our long-term vision. Version numbers will be assigned as we approach implementation.*

### AI-Native Framework

- **LLM Integration**: First-class support for AI models
- **Prompt Management**: Version and test prompts
- **RAG Pipelines**: Built-in retrieval-augmented generation
- **Agent Frameworks**: Multi-agent orchestration

### Distributed Computing

- **Cluster Mode**: Scale across multiple machines
- **Workflow Engine**: Complex DAG execution
- **Event Sourcing**: Built-in event store
- **CQRS Support**: Command/query separation

### Language Expansion

- **Type Hints**: Full runtime validation with beartype
- **Rust Extensions**: Performance-critical components
- **WebAssembly**: Run bricks in browsers
- **Cross-Language**: Polyglot brick composition

## Community & Ecosystem

### Governance

- **RFC Process**: Community-driven feature development
- **Stability Guarantee**: Clear deprecation policies
- **Security Process**: Vulnerability disclosure and fixes
- **Release Cadence**: Predictable release schedule

### Ecosystem Growth

- **Plugin Registry**: Discover and share bricks
- **Certification Program**: Quality standards for third-party bricks
- **Corporate Sponsors**: Sustainable development funding
- **Academic Partnerships**: Research and education

## Migration Strategy

### Version Compatibility

- **Semantic Versioning**: Strict adherence to SemVer
- **Deprecation Warnings**: Two minor versions before removal
- **Migration Tools**: Automated upgrades where possible
- **Compatibility Layer**: Support for older brick versions

### Adoption Path

1. **Early Adopters** (now - v0.2.x): Feedback and iteration
2. **Production Users** (v0.3.x+): Stable core with growing standard library
3. **Enterprise** (v0.5.x+): Advanced features and production support
4. **Mainstream** (v1.0+): Mature ecosystem with API stability guarantee

### Version Planning Philosophy

Starting with v0.2.1, we're adopting a more flexible approach to version planning:

- **Feature-Driven Releases**: Version numbers assigned when features are ready
- **No Fixed Timeline**: Quality and completeness over arbitrary deadlines  
- **Community Input**: Feature prioritization based on user feedback
- **Semantic Versioning**: Strict adherence to SemVer principles
- **.x Notation**: Future versions use .x to indicate flexibility in exact numbering

This approach provides:
- **Signal of Intent**: Clear indication of planned features and their themes
- **Implementation Flexibility**: Freedom to adjust based on real-world needs
- **Quality Focus**: Features ship when they're ready, not when scheduled

## Success Metrics

- **Developer Satisfaction**: >4.5/5 in surveys
- **Adoption**: 10k+ GitHub stars, 100k+ monthly downloads
- **Performance**: <1% overhead vs hand-written code
- **Reliability**: 99.99% uptime in production deployments
- **Community**: 100+ contributors, 1000+ third-party bricks

## Getting Involved

- **GitHub Discussions**: Share ideas and feedback
- **RFC Process**: Propose new features
- **Contributing**: Code, documentation, examples
- **Sponsorship**: Support sustainable development

---

*This roadmap is a living document. We'll update it based on community feedback and real-world usage patterns. Your input shapes the future of nanobricks!*